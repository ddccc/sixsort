// c:/bsd/rigel/sort/Dsort.c
// Date: Fri May 02 15:24:07 2014
// (C) OntoOO/ Dennis de Champeaux

// Dutch flag type function that initializes the middle segment in the middle
void dflgm(int N, int M, int pivotx, void (*cut)(), int depthLimit) {
  // printf("dflgm N %i M %i pivotx %i dl %i\n", N,M,pivotx,depthLimit);  
  /*
    This version is the fastest among 5-6 versions we have tried.
    Still there is info loss going on.  Hence improvements are plausible.
   */
  /*
    This dutch-flag-type sorter can be used as-is when called by something like:
<<<
void dflgmTest(int N, int M) {
  int L = M - N; 
  int depthLimit = 2 * floor(log(L));
  dflgmTest2(N, M, depthLimit);
}

void dflgmTest2(int N, int M, int depthLimit) {
  if ( depthLimit <= 0 ) { // avoid quadradic explosion
    heapc(A, N, M);
    return;
  }
  if ( M-N <= 1 ) { 
     insertionSortLoopUnroll(N, M);
     return;
  }
  dflgm(N, M, (N+M)/2, dflgmTest2, depthLimit-1);
}
>>>
   */
  /*
    Simple version of partitioning with: L/M/R
    L < pivot, M = pivot, R > pivot
   */
  register int i, j, lw, up, k; // indices
  register void* p3; // pivot
  register void* ai, *aj, *alw, *ak; // values
  register int r; // compare output

  // int z; // for tracing

  i = N; j = M; lw = pivotx-1; up = pivotx+1;
    /*
      |---)-----(----)-------(----|
      N   i     lw  up       j    M
      
      N <= i < lw <= up < j <= M
      N <= x < i ==> A[x] < p3
      lw < x < up  ==> A[x] = p3
      j < x <= M & ==> p3 < A[x] 
    */
  p3 = A[pivotx]; // There IS a middle value somewhere:

  // while ( N <= lw && A[lw] == p3 ) lw--;
  while ( N <= lw && compareXY(A[lw], p3) == 0 ) lw--;
  // while ( up <= M && p3 == A[up] ) up++;
  while ( up <= M && compareXY(p3, A[up]) == 0 ) up++;
  if ( lw < N ) {
    i--;
    if ( M < up ) { j++; goto done; }
    goto xleftClosed0;
  }
  if ( M < up ) { j++; goto xrightClosed0; }

 x0:
    /*
      |---)-----(----)-------(----|
      N   i     lw  up       j    M
      N <= i <= lw up <= j <= M 
    */
  alw = A[lw];
  // if ( alw < p3 ) goto xalwL; 
  if ( (r = compareXY(alw, p3)) < 0 ) goto xalwL; 
  // if ( p3 < alw ) goto xalwR;
  if ( 0 < r ) goto xalwR;
  // p3 = alw
  if ( i == lw ) {
    i--; goto xleftClosed0; 
  }
  // i < lw
  lw--;
  goto x0;

 xalwL:
    /*
      |---)-----(----)-------(----|
      N   i     lw  up       j    M
      i <= lw  up <= j alw -> L
    */
  // while ( A[i] < p3 ) i++;
  while ( compareXY(A[i], p3) < 0 ) i++;
  if ( lw < i ) { i--; goto xleftClosed0; }
  // i < lw  (alw < p3 <= A[i])
  ai = A[i];
  // if ( ai == p3 ) {
  if ( compareXY(ai, p3) < 0 ) {
    A[i++] = alw; A[lw--] = ai;
    if ( i <= lw ) goto x0; // info loss
    i--; goto xleftClosed0;
  }
  // p3 < ai
  goto xalwLaiR;
  
 xalwR:
    /*
      |---)-----(----)-------(----|
      N   i     lw  up       j    M
      i <= lw  up <= j alw -> R
    */
  // while ( p3 < A[j] ) j--;
  while ( compareXY(p3, A[j]) < 0 ) j--;
  if ( j < up ) {
    A[lw] = A[j]; // OK for phase shift
    A[j] = alw;
    goto xrightClosed0;
  }
  // up <= j
  aj = A[j]; // aj <= p3
  // if ( aj == p3 ) {
  if ( compareXY(p3, aj) == 0 ) {
    A[lw--] = aj; A[j--] = alw;
    if ( j < up ) { 
      j++; // right closed
      if ( lw < i ) { i--; goto done; }
      // i <= lw
      goto xrightClosed0;      
    }
    // up <= j
    if ( lw < i ) { i--; goto xleftClosed0; }
    goto x0; // info loss
  }
  // aj < p3
  goto xalwRajL;

 xalwLaiR:
    /*
      |---)-----(----)-------(----|
      N   i     lw  up       j    M
      i < lw up <= j alw -> L ai -> R  
    */
  aj = A[j];
  // if ( aj == p3 ) { // aj -> M
  if ( (r = compareXY(aj, p3)) == 0 ) { // aj -> M
    A[j--] = ai; A[lw--] = aj; A[i++] = alw;
    if ( lw < i ) { 
      i--; // left closed
      if ( j < up ) { // right closed
	j++; goto done;
      }
      // up <= j
      goto xleftClosed0; // info loss
    }
    // i <= lw
    if ( j < up ) { // right closed
      j++; goto xrightClosed0;
    }
    // up <= j
    goto x1;
  }  
  // if ( aj < p3 ) { // aj -> L
  if ( r < 0 ) { // aj -> L
    A[j--] = ai; A[i++] = aj; // i <= lw
    if ( j < up ) { // right closing
      j++;
      // alw -> L is lost
      goto xrightClosed0;
    }
    // up <= j and i <= lw ! and alw -> L  
    goto xalwL;
  }
  // aj -> R
  j--;
  if ( up <= j ) goto xalwLaiR;
  // j < up   right closed
  A[i++] = alw; A[lw--] = A[j]; A[j] = ai; 
  if ( lw < i ) { i--; goto done; }
  goto xrightClosed0;

 xalwRajL:
  /*
    |---)-----(----)-------(----|
    N   i     lw  up       j    M
    i <= lw up <= j alw -> R aj -> L
  */
  ai = A[i];
  // if ( ai == p3 ) { // ai -> M
  if ( (r = compareXY(ai, p3)) == 0 ) { // ai -> M
    A[i++] = aj; A[lw--] = ai; A[j--] = alw;
    if ( lw < i ) { 
      i--; // left closed
      if ( j < up ) { // right closed
	j++; goto done;
      }
      // up <= j
      goto xleftClosed0; // info loss
    }
    // i <= lw
    if ( j < up ) { // right closed
      j++; goto xrightClosed0;
    }
    // up <= j
    goto x1;
  } 
  // if ( p3 < ai ) { // ai -> R
  if ( 0 < r ) { // ai -> R
    if ( i == lw ) { // left closing
      A[i] = aj; A[j--] = ai;
      if ( j < up ) { j++; goto done; }
      // up <= j
      goto xleftClosed0;
    }
    // i < lw
    A[i++] = aj; A[j--] = ai;
    if ( j < up ) { // right closed
      j++; goto xrightClosed0;
    }
    goto xalwR;
  }
  // ai -> L, thus i < lw
  i++;
  goto xalwRajL;

 x1:
    /*
      |---)-----(----)-------(----|
      N   i     lw  up       j    M
      N < i <= lw up <= j < M 
    */
  // while ( A[lw] == p3 ) lw--;
  while ( compareXY(A[lw], p3) == 0 ) lw--;
  // while ( A[up] == p3 ) up++;
  while ( compareXY(A[up], p3) == 0 ) up++;
  if ( lw < i ) { // left closed
    i--;
    if ( j < up ) { j++; goto done; }
    // up < j
    goto xleftClosed0;
  }
  // i <= lw
  if ( j < up  ) { j++; goto xrightClosed0; }
  // up <= j
  goto x0; // info loss

 xleftClosed0:
    /*
      |---]---------)-------(----|
      N   i        up       j    M
      up <= j 
    */
  for (k = up; k <= j; k++) {
    ak = A[k];
    // if ( ak == p3 ) continue;
    if ( (r = compareXY(ak, p3)) == 0) continue;
    // if ( ak < p3 ) { A[k] = A[++i]; A[i] = ak; continue; }
    if ( r < 0 ) { A[k] = A[++i]; A[i] = ak; continue; }
    // p3 < ak
    // while ( p3 < A[j]  ) j--;
    while ( compareXY(p3, A[j]) < 0 ) j--;
    if ( j < k  ) { j = k; goto done; }
    // k < j
    aj = A[j]; // aj <= p3
    A[j--] = ak;
    // if ( aj == p3 ) {
    if ( compareXY(aj, p3) == 0 ) {
      A[k] = aj; continue;
    }
    // aj < p3
    A[k] = A[++i]; A[i] = aj; // continue
  }
  j++;
  goto done;

 xrightClosed0:
    /*
      |---)-----(-----------[----|
      N   i     lw          j    M
      i <= lw 
    */
   for (k = lw; i <= k; k--) {
    ak = A[k];
    // if ( ak == p3 ) continue;
    if ( (r = compareXY(ak, p3)) == 0 ) continue;
    // if ( ak > p3 ) { A[k] = A[--j]; A[j] = ak; continue; }
    if ( r > 0 ) { A[k] = A[--j]; A[j] = ak; continue; }
    // ak < p3
    // while ( A[i] < p3 ) i++;
    while ( compareXY(A[i], p3) < 0 ) i++;
    if ( k < i ) { i = k; goto done; }
    // i < k
    ai = A[i]; // p3 <= ai
    A[i++] = ak;
    // if ( ai == p3 ) {
    if ( compareXY(ai, p3) == 0 ) {
      A[k] = ai; continue;
    }
    // p3 < ai
    A[k] = A[--j]; A[j] = ai; // continue    
  }
  i--;
  // goto done;

 done: 
    /*
      |---]---------[---------|
      N   i         j         M
    */
  // printf("done dflgm N %i i %i j %i M %i\n", N,i,j,M);

  /*
      for ( z = N; z <= i; z++ )
	// if ( p3 <= A[z] ) {
	if ( compareXY(p3, A[z]) <= 0 ) {
	  printf("doneL z %i\n", z);
	  printf("N %i i %i lw %i up %i j %i M %i\n", N,i,lw,up,j,M);
	  exit(0);
	}
      for ( z = i+1; z < j; z++ )
	// if ( p3 != A[z] ) {
	if ( compareXY(p3, A[z]) != 0 ) {
	  printf("doneM z %i\n", z);
	  printf("N %i i %i lw %i up %i j %i M %i\n", N,i,lw,up,j,M);
	  exit(0);
	}
      for ( z = j; z <= M ; z++ )
	// if ( A[z] <= p3 ) {
	if ( compareXY(A[z], p3) <= 0 ) {
	  printf("doneR z %i\n", z);
	  printf("N %i i %i lw %i up %i j %i M %i\n", N,i,lw,up,j,M);
	  exit(0);
	}
      */
    if ( i - N  < M - j ) {
      (*cut)(N, i, depthLimit);
      (*cut)(j, M, depthLimit);
      return;
    }
    (*cut)(j, M, depthLimit);
    (*cut)(N, i, depthLimit);
} // end dflgm
