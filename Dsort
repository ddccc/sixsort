// c:/bsd/rigel/sort/Dsort
// Date: Fri Jan 31 13:32:12 2014
// (C) OntoOO/ Dennis de Champeaux


// Dutch flag type function that initializes the middle segment in the middle
void dflgm(int N, int M, int pivotx, void (*cut)(), int depthLimit) {
  // printf("dflgm N %i M %i pivotx %i dl %i\n", N,M,pivotx,depthLimit);  
  /*
    Simple version of partitioning with: L/M/R
    L < pivot, M = pivot, R > pivot
   */
  register int i, j, lw, up; // indices
  register void* p3; // pivot
  register void* ai, *aj, *am;
  register int r; // comparison output 
  // int z; // for tracing

  if ( depthLimit <= 0 ) { // avoid quadradic explosion
    heapc(A, N, M);
    return;
  }

  int L = M - N;
  // delegated small segments
  // if ( L < cut3xLimit ) {
  if ( L < 100 ) {
    quicksort0c(N, M, depthLimit);
    return;
  }

  i = N; j = M; lw = pivotx-1; up = pivotx+1;
    /*
      |---)-----(----)-------(----|
      N   i     lw  up       j    M
      
      N <= i < lw <= up < j <= M
      N <= x < i ==> A[x] < p3
      lw < x < up  ==> A[x] = p3
      j < x <= M & ==> p3 < A[x] 
    */
  p3 = A[pivotx]; // There IS a middle value somewhere:

 L0:
   /*
     |---)-----(----)-------(----|
     N   i     lw  up       j    M
   */

  // while ( A[i] < p3 ) i++;
  while ( (r = compareXY(A[i], p3)) < 0 ) i++;
  if ( lw < i ) {
    i--;
    if ( N < i ) goto leftClosed;
    i = N;
    goto leftEmpty;
  }
  ai = A[i]; // p3 <= ai
  // if ( p3 < ai ) goto LaiR; 
  if ( 0 < r ) goto LaiR; 
  goto LaiM;

 LaiR:
   /*
      |---)-----(----)-------(----|
      N   i     lw  up       j    M
      ai -> R
   */
  // while ( p3 < A[j] ) j--;
  while ( (r = compareXY(p3, A[j])) < 0 ) j--;
  aj = A[j]; // aj <= p3
  // if ( aj < p3 ) { // aj -> L
  if ( 0 < r ) {
    A[i] = aj; A[j] = ai; 
    goto L1; }
  // aj -> M
  if ( j <= up ) {
    if ( j == M ) goto emptyRightaiR;
    j++; goto rightClosedaiR;
  }
  // up < j
  am = A[up];
  // if ( am < p3 ) { // am -> L
  if ( (r = compareXY(am, p3)) < 0 ) {
    A[i] = am; A[up++] = aj; A[j] = ai;
    goto L1; 
  }
  // if ( p3 < am ) { // am -> R
  if ( 0 < r ) {
    A[up++] = aj; A[j--] = am; 
    if ( j < up ) { j++; goto rightClosedaiR; }
    // up <= j
    goto LaiR; // info loss ...
  }
  // am -> M
  up++;
  goto LaiR;

 LaiM:
   /*
      |---)-----(----)-------(----|
      N   i     lw  up       j    M
      ai -> M
   */
  // while ( N < lw && A[lw] == p3 ) lw--;
  while ( N < lw && (r = compareXY(A[lw], p3)) == 0 ) lw--;
  if ( N == lw ) { goto leftEmpty; }
  // N < lw
  if ( i == lw ) { i--; goto leftClosed; }
  // i < lw
  am = A[lw];
  // if ( am < p3 ) { // am -> L
  if ( r < 0 ) {
    A[i++] = am; A[lw--] = ai;
    if ( lw < i ) { i--; goto leftClosed; }
    goto L0; // info loss
  }
  // am -> R
  // while ( p3 < A[j] ) j--;
  while ( (r = compareXY(p3, A[j])) < 0 ) j--;
  aj = A[j]; // aj <= p3
  // if ( aj < p3 ) { // aj -> L
  if ( 0 < r ) {
    A[i] = aj; A[lw--] = ai; A[j] = am;
    goto L1;
  }
  // aj -> M
  if ( j < up ) {
    A[lw--] = aj; A[j] = am;
    goto rightClosedaiM;
  }
  // up <= j
  A[lw--] = aj; A[j--] = am;
  if ( j < up ) {
    j++; // right side closed
    if ( i == lw ) { // left side closed
      i--; goto done;
    }
    goto rightClosedaiM;
  }
  // up <= j
  if ( i == lw ) {
    i--; goto leftClosed;
  }
  goto LaiM; // info loss
  
 leftEmpty:
   /*
      |-------------)-------(----|
    N=i             up      j    M
   */
  // while ( up <= M && A[up] == p3 ) up++;
  while ( up <= M && (r = compareXY(A[up], p3)) == 0 ) up++;
  if ( M < up ) return; // !!
  if ( j < up ) { j++; goto done; }
  // up <= j
  am = A[up];
  // if ( am < p3) { // am -> L
  if ( r < 0 ) {
    A[up++] = A[N]; A[N] = am; 
    if ( j < up ) { j++; goto done; }
    // up <= j
    goto leftClosed;
  }
  // am -> R
  // while ( p3 < A[j] ) j--;
  while ( (r = compareXY(p3, A[j])) < 0 ) j--;
  if ( j < up ) { j++; goto done; }
  // up < j
  aj = A[j]; // aj <= p3
  // if ( aj < p3 ) { // aj -> L
  if ( 0 < r ) {
    A[j--] = am; A[up++] = A[N]; A[N] = aj;
    if ( j < up ) { j++; goto done; }
    goto leftClosed;
  }
  // aj -> M
  A[j--] = am; A[up++] = aj;
  if ( j < up ) { j++; goto done; }
  goto leftEmpty;
  
 emptyRightaiR:
   /*
      |---)-----(---------------|
      N   i     lw              j=M
      ai -> R
   */
  // while ( A[lw] == p3 ) lw--;
  while ( (r = compareXY(A[lw], p3)) == 0 ) lw--;
  am = A[lw];
  // if ( p3 < am ) { // am -> R
  if ( 0 < r ) {
    if ( i == lw ) {
      A[i] = A[M]; A[M] = ai; i--; goto done;
    }
    // i < lw
    A[lw--] = A[M]; A[M] = am; goto rightClosedaiR;
  }
  // am -> L
  A[i++] = am; A[lw--] = A[M]; A[M] = ai;
  if ( lw < i ) { i--; goto done; }
  goto rightClosed;

  L1: 
  /*
    |---]-----(----)-------[----|
    N   i     lw  up       j    M
  */
  // while ( A[++i] < p3 );
  while ( (r = compareXY(A[++i], p3)) < 0 );
  if ( lw < i ) { i--; j--; goto leftClosed; }
  // i <= lw
  ai = A[i];
  // if ( p3 < ai ) { // ai -> R
  if ( 0 < r ) {
  L1Repeat:
    // while ( p3 < A[--j] );
    while ( (r = compareXY(p3, A[--j])) < 0 );
    if ( j < up ) { j++; goto rightClosedaiR; }
    // up <= j
    aj = A[j];
    // if ( aj < p3 ) { // aj -> L
    if ( 0 < r ) {
      A[i] = aj; A[j] = ai; 
      goto L1;
    }
    // aj -> M
    // while ( A[up] == p3 ) up++;
    while ( (r = compareXY(A[up], p3)) == 0 ) up++;
    if ( j < up ) { j++; goto rightClosedaiR; }
    // up <= j
    am = A[up];
    // if ( am < p3 ) { // am -> L
    if ( r < 0 ) {
      A[i] = am; A[up++] = aj; A[j] = ai;
      if ( j < up ) { i++; goto rightClosed; }
      goto L1;
    }
    // am -> R
    A[up++] = aj; A[j] = am;
    if ( j < up ) { goto rightClosedaiR; }
    // up <= j
    goto L1Repeat;
  }
  // ai -> M
 L1Repeat2:
  // while ( A[lw] == p3 ) lw--;
  while ( (r = compareXY(A[lw], p3)) == 0 ) lw--;
  if ( lw < i ) { i--; j--; goto leftClosed; }
  // i < lw
  am = A[lw]; 
  // if ( am < p3 ) { // am -> L
  if ( r < 0 ) {
    A[i] = am; A[lw--] = ai;
    if ( lw < i ) { i--; j--; goto leftClosed; } 
    goto L1;
  }
  // am -> R
  // while ( p3 < A[--j] );
  while ( (r = compareXY(p3, A[--j])) < 0 );
  if ( j < up ) {
    A[lw--] = A[j]; A[j] = am; goto rightClosedaiM;
  }
  // up <= j
  aj = A[j];
  // if ( aj < p3 ) { // aj -> L
  if  ( 0 < r ) {
    A[i] = aj; A[lw--] = ai; A[j] = am;
    if ( lw < i ) { j--; goto leftClosed; }
    goto L1;
  }
  // aj -> M
  A[lw--] = aj; A[j] = am; 
  goto L1Repeat2;

 leftClosed: 
   /* 
      |---]----------)-------(----|
      N   i          up      j    M
   */
  // while ( p3 < A[j] ) j--;
  while ( (r = compareXY(p3, A[j])) < 0 ) j--;
  if ( j < up ) { j++; goto done; }
  // up <= j
  aj = A[j]; // aj <= p3
  // if ( aj < p3 ) { // aj -> L
  if ( 0 < r ) {
    repeatM:
    // while ( A[up] == p3 ) up++;
    while ( (r = compareXY(A[up], p3)) == 0 ) up++;
    am = A[up];
    // if ( p3 < am ) { // am -> R
    if ( 0 < r ) {
      A[j--] = am; A[up++] = A[++i]; A[i] = aj;
      if ( j < up ) { j++; goto done; }
      goto leftClosed;
    }
    // am -> L
    if ( up == j ) { A[j++] = A[++i]; A[i] = am; goto done; }  
    // up < j
    A[up++] = A[++i]; A[i] = am;
    goto repeatM;
  }
  // aj -> M
  repeatM2:
  // while ( up <= j && A[up] == p3 ) up++;
  while ( up <= j && (r = compareXY(A[up], p3)) == 0 ) up++;
  if ( j <= up ) { j++; goto done; }
  // up < j
  am = A[up];
  // if ( p3 < am ) { // am -> R
  if ( 0 < r ) {
    A[j--] = am; A[up++] = aj;
    if ( j < up ) { j++; goto done; }
    goto leftClosed;
  }
  // am -> L
  A[up++] = A[++i]; A[i] = am; 
  goto repeatM2;

 rightClosed:
   /*
      |---)-----(-----------[----|
      N   i    lw           j    M
   */
  // while ( A[i] < p3 ) i++;
  while ( (r = compareXY(A[i], p3)) < 0 ) i++;
  if ( lw < i ) { i--; goto done; }
  // i <= lw
  ai = A[i]; // p3 <= ai
  // if ( p3 < ai ) { // ai -> R
  if ( 0 < r ) {
    goto rightClosedaiR;
  }
  // ai -> M
  // goto rightClosedaiM;

 rightClosedaiM:
  // while ( i <= lw && A[lw] == p3 ) lw--;
  while ( i <= lw && (r = compareXY(A[lw], p3)) == 0 ) lw--;
  if ( lw < i ) { i--; goto done; }
  // i <= lw
  am = A[lw];
  // if ( p3 < am ) { // am -> R
  if ( 0 < r ) {
    A[lw--] = A[--j]; A[j] = am; 
    if ( lw < i ) { i--; goto done; }
    goto rightClosedaiM;
  }
  // am -> L
  A[i++] = am; A[lw--] = ai;
  if ( lw < i ) { i--; goto done; }
  goto rightClosed;

 rightClosedaiR: 
   /*
      |---)-----(-----------[----|
      N   i    lw           j    M
      ai -> R
   */
  // while ( A[lw] == p3 ) lw--;
  while ( (r = compareXY(A[lw], p3)) == 0 ) lw--;
  if ( i == lw ) {
    A[i--] = A[--j]; A[j] = ai; goto done;
  }
  // i < lw
  am = A[lw];
  // if ( am < p3 ) { // am -> L
  if ( r < 0 ) {
    A[i++] = am; A[lw--] = A[--j]; A[j] = ai;
    if ( lw < i ) { i--; goto done; }
    // i <= lw
    goto rightClosed;
  }
  // am -> R
  A[lw--] = A[--j]; A[j] = am; goto rightClosedaiR;
  
 done: 
    /*
      |---]---------[---------|
      N   i         j         M
    */
  // printf("done dflgm N %i i %i j %i M %i\n", N,i,j,M);

    /*
      for ( z = N; z <= i; z++ )
	// if ( p3 <= A[z] ) {
        if ( compareXY(p3, A[z]) <= 0 ) {
	  printf("doneL z %i\n", z);
	  printf("N %i i %i lw %i up %i j %i M %i\n", N,i,lw,up,j,M);
	  exit(0);
	}
      for ( z = i+1; z < j; z++ )
	// if ( p3 != A[z] ) {
	if ( compareXY(p3, A[z]) != 0 ) {
	  printf("doneM z %i\n", z);
	  printf("N %i i %i lw %i up %i j %i M %i\n", N,i,lw,up,j,M);
	  exit(0);
	}
      for ( z = j; z <= M ; z++ )
	// if ( A[z] <= p3 ) {
	if ( compareXY(A[z], p3) <= 0 ) {
	  printf("doneR z %i\n", z);
	  printf("N %i i %i lw %i up %i j %i M %i\n", N,i,lw,up,j,M);
	  exit(0);
	}
      */
    if ( i - N  < M - j ) {
      (*cut)(N, i, depthLimit);
      (*cut)(j, M, depthLimit);
      return;
    }
    (*cut)(j, M, depthLimit);
    (*cut)(N, i, depthLimit);
} // end dflgm

